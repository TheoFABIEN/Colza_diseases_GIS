import geopandas as gpd
import numpy as np
from scipy.spatial.distance import cdist, pdist, squareform
from shapely.geometry import Polygon, mapping




def calculate_metrics(shapefile, round_val):
    """
    Calculates the given metrics for a shapefile:
    - Number of colza fields
    - Total surface of colza
    - Surface of annual crops 
    - Surface of perennial crops 
    
    Parameters:
    shapefile (GeoDataFrame): Dataframe containing shapefile data.
    
    Returns:
    list of strings representing the calculated metrics.
    """
    return [
        str(len(shapefile[shapefile['CodeAgg'] == 'Col'])),
        str(round(
            shapefile[shapefile['CodeAgg'] == 'Col']['SURF_PARC'].sum(), 
            round_val
        )),
        str(round(
            shapefile[shapefile['CodeAgg'] == 'Ann']['SURF_PARC'].sum(), 
            round_val
        )),
        str(round(
            shapefile[shapefile['CodeAgg'] == 'Per']['SURF_PARC'].sum(), 
            round_val
        ))
    ]



def semivariogram(risk_map, n_samples = 500, max_distance = None):
    """
    Calculate the semivariogram of the given risk map.

    Parameters:
    risk_map (numpy array of shape (m, n)): The risk map.
    n_samples (int, optional): The number of random samples to extract from the 
    risk map. Default is 500.
    max_distance (float, optional): The maximum distance to consider when 
    calculating the semivariogram. Default is None.

    Returns:
    bin_centers (numpy array of shape (k,)): The centers of the distance bins.
    semivariance_values (numpy array of shape (k,)): The average semivariance 
    for each distance bin.
    """
    # Extract random coordinates and values
    coordinates = np.random.randint(0, len(risk_map), (n_samples, 2))
    values = np.asarray(
        [risk_map[x, y] for x, y in coordinates]
    )

    # Get the pairwise distances between coordinates
    distances = pdist(coordinates)
    semivariances = pdist(values.reshape(-1, 1), metric = 'sqeuclidean') / 2

    # Convert to a square form matrix
    distance_matrix = squareform(distances)
    semivariance_matrix = squareform(semivariances)


    # Get unique distance bins
    if max_distance is None:
        max_distance = np.max(distances)
    bins = np.linspace(0, max_distance, num = 50)
    bin_centers = (bins[:-1] + bins[1:]) / 2
    
    # Calculate average semivariance for each bin 
    semivariance_values = np.zeros_like(bin_centers)
    for i in range(len(bins) - 1):
        mask = (distances >= bins[i]) & (distances < bins[i + 1])
        semivariance_values[i] = np.mean(semivariances[mask])

    return bin_centers, semivariance_values



def closest_distances(geodata1, geodata2):
    """
    Calculate the Euclidean distance between each centroid in shapefile 2
    and the closest centroid from shapefile 1.
    
    Parameters:
    geodata1 (GeoDataFrame)
        The first shapefile (shapefile 1) containing polygons.
    geodata2 (GeoDataFrame)
        The second shapefile (shapefile 2) containing polygons.
        
    Returns:
    min_distances (numpy array)
        An array of the minimum Euclidean distances between each centroid in 
        shapefile 2 and the closest centroid in shapefile 1.
    """
    # Extract centroids
    centroids1 = np.array(
        [(geom.centroid.x, geom.centroid.y) 
         for geom in geodata1.geometry]
    )
    centroids2 = np.array(
        [(geom.centroid.x, geom.centroid.y) 
         for geom in geodata2.geometry]
    )
    
    # Calculate pairwise distances
    distances = cdist(centroids2, centroids1)
    
    # Find the minimum distance for each centroid in shapefile 2
    min_distances = np.min(distances, axis = 1)
    
    return min_distances
    
    
    
    
# Next 2 functions will be used for analysis of contact zones between places 
# where colza was at year n and places where colza was at year n+1
    
    
    
def lines_to_polygons(lines):
    """
    Converts closed LineStrings or MultiLineStrings to Polygon objects.
    This function will only be used in contact_zones_highlighter()

    Parameters:
    lines (list): A list of shapely LineString or MultiLineString objects.

    Returns:
    polygons (list): A list of shapely Polygon objects converted from closed 
    LineStrings or MultiLineStrings.
    """
    polygons = []
    for line in lines:
        if line.geom_type == "LineString" and line.is_closed:  # Check if the LineString is a closed loop
            polygons.append(Polygon(line))
        elif line.geom_type == 'MultiLineString':
            for geom in line.geoms:
                if geom.is_closed:
                    polygons.append(Polygon(geom))
    return polygons


def contact_zones_highlighter(shapefile_1, shapefile_2, 
                               buffer_distance = 1, crs = None):                                              
    """
    Finds and returns the shared boundaries between two shapefiles as a 
    GeoDataFrame of Polygons. It does so by buffering the geometries in the 
    input shapefiles by a given distance, and then find intersections. The 
    intersection are then converted to polygons.

    Parameters:
    shapefile_1 (GeoDataFrame): The first input GeoDataFrame.
    shapefile_2 (GeoDataFrame): The second input GeoDataFrame.
    buffer_distance (float, optional): The distance to buffer the geometries. 
                                       Default is 1.
    crs (str or int, optional): The Coordinate Reference System to use for the 
                                output GeoDataFrame. Default is None.

    Returns:
    polygons_gdf (GeoDataFrame): A GeoDataFrame containing the shared boundaries 
                                 as Polygon objects.
    """      
    shapefile_1 = shapefile_1.copy()
    shapefile_2 = shapefile_2.copy()                                                  
    shapefile_1['geometry'] = shapefile_1.buffer(buffer_distance)
    shapefile_2['geometry'] = shapefile_2.buffer(buffer_distance)
    
    shared_boundaries = []
    
    for poly1 in shapefile_1['geometry']:
        for poly2 in shapefile_2['geometry']:
            intersection = poly1.intersection(poly2)
            if not intersection.is_empty:
                # Extract the shared boundary (line segments)
                shared_boundary = intersection.boundary
                shared_boundaries.append(shared_boundary)
    
    # Create a GeoDataFrame to store the shared boundaries
    shared_gdf = gpd.GeoDataFrame(geometry=shared_boundaries)
    #shared_gdf['length'] = shared_gdf.length

    # Create a gdf containing polygons instead of linestrings
    lines = shared_gdf.geometry
    polygons = lines_to_polygons(lines)
    polygons_gdf = gpd.GeoDataFrame(geometry = polygons, crs = crs)

    return polygons_gdf
   

from skimage.draw import polygon2mask

def calculate_risk(polygon, risk_map, min_x, min_y, total_risk = False):
    """
    Computes the risk of infection on a given polygon. 
    Parameters:
    polygon (shapely.geometry.Polygon): Polygon on which to calculate the risk
    risk_map (numpy.ndarray): Risks of infection in the study area, computed 
                              from data of the previous year.
    min_x, min_y (float): minimal x and y coordinates of the shapefile the 
                           polygon is from. It is subtracted from the polygon
                           coordinates to align it with the risk map.
    total_risk (bool): whether to compute sum of risks instead of mean risk.
    Returns:
    mean_risk: Mean risk of infection in the area covered by the polygon.
    total_risk: Sum of risks in the area covered by the polygon.
    """
    points = list(polygon.exterior.coords)
    points_new_coords = [
        (int(y - min_y), int(x - min_x))
        for (x, y) in points
    ]

    imgp2 = polygon2mask(risk_map.shape, points_new_coords)
    imgp2 = np.flip(imgp2, axis = 0)

    if total_risk:
        total_risk = np.sum(risk_map[imgp2])
        return total_risk

    mean_risk = np.mean(risk_map[imgp2])
    return mean_risk

import matplotlib.pyplot as plt

def random_colza_selection_risk_distribution(shapefile, min_x, min_y, risk_map = None,
                                             num_samples = 5, num_iter = 10):
    """
    Gives distribution of risks of infection by over random selections of a 
    given number of polygons that may contain colza. 

    Parameters:
    shapefile (geopandas.GeoDataFrame): A GeoDataFrame containing polygons 
                                        representing colza crops.
    num_samples (int): The number of polygons to select at random for each 
                       iteration.
    num_iterations (int): The number of iterations to run the simulation.
    risk_map (numpy.ndarray): Risks of infection in the study area, computed
                              from data of the previous year.
    min_x, min_y (float): Arguments used in calculate_risk().

    Returns:
    matplotlib.figure.Figure: Distribution of total risks after a large number
                               of random draws. 
    """
    if risk_map is None:
        raise ValueError('A risk map must be provided.')
    
    shapefile['risk'] = shapefile.apply(
        lambda row: calculate_risk(row['geometry'], risk_map, min_x, min_y),
        axis = 1
    )

    total_risks = [
        shapefile.sample(num_samples)['risk'].sum()
        for _ in range(num_iter)
    ]

    fig, ax = plt.subplots()
    ax.hist(total_risks, bins = 50, density = True)
    ax.set_xlabel('Total Risk'),
    ax.set_ylabel('Probability density')
    ax.set_title(f'Distribution of risk after {num_iterations} iterations')

    return fig


    
    
    
    
    


